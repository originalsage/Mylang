// =============================================================================
// MyLang è¯æ³•åˆ†æå™¨ï¼ˆLexerï¼‰
// åŠŸèƒ½ï¼šä»æºæ–‡ä»¶è¯»å–å­—ç¬¦æµï¼Œè¯†åˆ«å¹¶ç”Ÿæˆ Token åºåˆ—
// ä½œè€…ï¼šæéš†ç”Ÿï¼ˆ23009200365ï¼‰
// æ—¥æœŸï¼š2025-12-05
// è¯­è¨€ï¼šä»“é¢‰ï¼ˆCangjieï¼‰
// ä¾èµ–ï¼šstd.fs, std.math, std.random, std.convert.Parsable, std.unicode
// -----------------------------------------------------------------------------
// æ ¸å¿ƒæ¥å£ï¼š
//   - initscanner(filePath: Path): Int64    // åˆå§‹åŒ–æ‰«æå™¨ï¼Œæ‰“å¼€æ–‡ä»¶
//   - getNextToken(): Token                 // è·å–ä¸‹ä¸€ä¸ª Token
//   - closescanner()                        // å…³é—­æ–‡ä»¶å¥æŸ„
// -----------------------------------------------------------------------------
// æ”¯æŒç‰¹æ€§ï¼š
//   - å…³é”®å­—ã€è¿ç®—ç¬¦ã€åˆ†éš”ç¬¦è¯†åˆ«
//   - æ•´æ•°/æµ®ç‚¹æ•°å­—é¢é‡è§£æ
//   - é¢œè‰²å¸¸é‡ï¼ˆBLACK/WHITE/RED/GREEN/BLUEï¼‰ã€æ•°å­¦å¸¸é‡ï¼ˆPI/Eï¼‰
//   - å†…ç½®å‡½æ•°ï¼ˆSIN/COS/...ï¼‰â†’ ç»‘å®šæ ‡å‡†åº“å‡½æ•°æŒ‡é’ˆ
//   - æ³¨é‡Šè·³è¿‡ï¼ˆ// ä¸ --ï¼‰
//   - é”™è¯¯è®°å·ï¼ˆERRTOKENï¼‰æŠ¥å‘Šéæ³•å­—ç¬¦
// =============================================================================
package Mylang
import std.fs.*
import std.math.*
import std.random.*
import std.convert.Parsable
import std.unicode.UnicodeStringExtension


//å…¨å±€å˜é‡file 
public var file:?File = None;
//è¯æ³•åˆ†æå™¨è¾…åŠ©å˜é‡
private let bytesBuf:Array<Byte> = Array<Byte>(4096,repeat:0);
private var index:Int64 = 0;

//TokeTypeæšä¸¾ç±»å‹
public enum TokenType{
    // å…³é”®å­—
    |ORIGIN|SCALE|ROT|COLOR|IS
    |FOR|FROM|TO|STEP|DRAW
    // å‚æ•°
    |T
    // åˆ†éš”ç¬¦
    |SEMICO|L_BRACKET|R_BRACKET|COMMA
    // è¿ç®—ç¬¦
    |PLUS|MINUS|MUL|DIV|POWER
    // å‡½æ•°
    |FUNC
    // å¸¸æ•°
    |CONST_ID
    // ç©ºè®°å·
    |NONTOKEN
    // é”™è¯¯è®°å·
    |ERRTOKEN
    public operator func == (right:TokenType):Bool{//ğŸ˜€
        return getTokenTypeName(this) == getTokenTypeName(right);
    }
    public operator func != (right:TokenType):Bool{//ğŸ˜€
        return getTokenTypeName(this) != getTokenTypeName(right);
    }
}
//å¯¹å¤–æ¥å£è·å–Typeç±»å‹å
public func getTokenTypeName(tokentype: TokenType): String {
    return match(tokentype) {
        case ORIGIN => "ORIGIN"
        case SCALE => "SCALE"
        case ROT => "ROT"
        case COLOR => "COLOR"
        case IS => "IS"
        case FOR => "FOR"
        case FROM => "FROM"
        case TO => "TO"
        case STEP => "STEP"
        case DRAW => "DRAW"
        case T => "T"
        case SEMICO => "SEMICO"
        case L_BRACKET => "L_BRACKET"
        case R_BRACKET => "R_BRACKET"
        case COMMA => "COMMA"
        case PLUS => "PLUS"
        case MINUS => "MINUS"
        case MUL => "MUL"
        case DIV => "DIV"
        case POWER => "POWER"
        case FUNC => "FUNC"
        case CONST_ID => "CONST_ID"
        case NONTOKEN => "NONTOKEN"
        case ERRTOKEN => "ERRTOKEN"
    }
}
//Tokenç»“æ„ä½“
public struct Token{
    
    public var tokentype:TokenType;//æ ‡è®°çš„ç±»å‹ä¿¡æ¯
    public var lexeme:String;//åŸå§‹æ–‡æœ¬å†…å®¹
    public var value:Float64;//æ•°å€¼ï¼ˆå¦‚æœæ˜¯å¸¸æ•°ï¼‰
    public var Func:?(Float64)->Float64;//å‡½æ•°æŒ‡é’ˆï¼ˆå¦‚æœæ˜¯å‡½æ•°åï¼‰
    public init(){
        this.tokentype = TokenType.NONTOKEN;
        this.value = 0.0;
        this.lexeme = "";
        this.Func = None;
    }
}
//è·å¾—ä¸€ä¸ªtoken
public func getNextToken():Token{
    var token:Token =Token();
    var ch:Rune = r'0';
    //1 è·³è¿‡ç©ºæ ¼ åˆ¶è¡¨ç¬¦ æ¢è¡Œ
    while(true){//EOF
        ch=readrune();
        if(ch == r' '|| ch == r'\t' || ch == r'\n' || ch == r'\r'){
            continue;
        }else{
            break;
        }
    }
    //2 å¦‚æœå½“å‰å­—ç¬¦ï¼ˆindex-1ï¼‰æ˜¯EOF
    if(ch_is_EOF()){
        token.tokentype=NONTOKEN;
        return token;
    }
    //3 æ³¨é‡Š // æˆ–è€… --
    if(ch == r'/'){
        ch = readrune();
        if (ch == r'/'){
            //å¤„ç† //æ³¨é‡Š
            while(true){
                ch = readrune();
                if(ch_is_EOF()){
                    token.tokentype = NONTOKEN;
                    return token;
                }else if(ch == r'\n'){
                    break;
                }
            }
            return getNextToken();
        }else{
            //å›é€€ä¸€å­—ç¬¦
            backrune();
            token.tokentype = DIV;
            token.lexeme = "/";
            return token;
        }
    }else if(ch == r'-'){
        ch = readrune();
            if (ch == r'-'){
            //å¤„ç† //æ³¨é‡Š
            while(true){
                ch = readrune();
                if(ch_is_EOF()){
                    token.tokentype = NONTOKEN;
                    return token;
                }else if(ch == r'\n'){
                    break;
                }
            }
            return getNextToken();
        }else{
            //å›é€€ä¸€å­—ç¬¦
            backrune();
            token.tokentype = MINUS;
            token.lexeme = "-";
            return token;
        }
    }

    //3æ•°å­— å¦‚3.14 , 89
    if (ch.isAsciiNumber()){
        var numstr:String = "";
        numstr += String(ch);
        while(true){
            ch = readrune();
            if(ch.isAsciiNumber()){
                numstr += String(ch);
            }else if (ch == r'.'){
                numstr += String(ch);
                while(true){
                    ch = readrune();
                    if(ch.isAsciiNumber()){
                        numstr += String(ch);
                    }else{
                        backrune();
                        break;
                    }
                }
            }else{
                backrune();
                break;
            }
        }
        token.tokentype = CONST_ID;
        token.lexeme = numstr;
        token.value = Float64.tryParse(numstr).getOrThrow();
        return token;
    }

    //4å­—æ¯
    if (ch.isAsciiLetter()){
        var str:String = "";
        str += String(ch);
        while(true){
            ch = readrune();
            if (ch.isAsciiLetter()){
                str += String(ch);
            }else{
                backrune();
                break;
            }
        }
        var idstr:String = str.toUpper();

        //æŸ¥è¡¨åˆ¤æ–­tokentype
        match (idstr) {
            case "ORIGIN" =>
                token.tokentype = ORIGIN
            case "SCALE" =>
                token.tokentype = SCALE
            case "ROT" =>
                token.tokentype = ROT
            case "COLOR" =>
                token.tokentype = COLOR
            case "IS" =>
                token.tokentype = IS
            case "TO" =>
                token.tokentype = TO
            case "STEP" =>
                token.tokentype = STEP
            case "DRAW" =>
                token.tokentype = DRAW
            case "FOR" =>
                token.tokentype = FOR
            case "FROM" =>
                token.tokentype = FROM
            case "BLACK" =>
                token.tokentype = CONST_ID
                token.value = Float64(0x000000)
            case "WHITE" =>
                token.tokentype = CONST_ID
                token.value = Float64(0xFFFFFF)
            case "RED" =>
                token.tokentype = CONST_ID
                token.value = Float64(0xFF0000)
            case "GREEN" =>
                token.tokentype = CONST_ID
                token.value = Float64(0x00FF00)
            case "BLUE" =>
                token.tokentype = CONST_ID
                token.value = Float64(0x0000FF)
            case "LLS" =>
                token.tokentype = CONST_ID
                token.value = Float64(Random().nextUInt32())
            case "PI" =>
                token.tokentype = CONST_ID
                token.value = 3.1415926535
            case "E" =>
                token.tokentype = CONST_ID
                token.value = 2.7182818284
            case "T" =>
                token.tokentype = T
            case "SIN" =>
                token.tokentype = FUNC;
                token.Func = sin;
            case "COS" =>
                token.tokentype = FUNC;
                token.Func = cos;
            case "TAN" =>
                token.tokentype = FUNC;
                token.Func = tan;
            case "LN" =>
                token.tokentype = FUNC;
                token.Func = log;
            case "EXP" =>
                token.tokentype = FUNC;
                token.Func = exp;
            case "SQRT" =>
                token.tokentype = FUNC;
                token.Func = sqrt;
            case "ABS" =>
                token.tokentype = FUNC;
                token.Func = abs;
            case _ =>
                token.tokentype = ERRTOKEN;
        }
        token.lexeme = str;
        return token;
    }
    
    //5 è¿ç®—ç¬¦å·å’Œåˆ†éš”ç¬¦
    match (ch){
        case r'+' =>
            token.tokentype = PLUS;
            token.lexeme ="+";
        case r'*' =>
            ch = readrune();
            if (ch == r'*'){
                token.tokentype = POWER;
                token.lexeme = "**";
            }else{
                backrune();
                token.tokentype = MUL;
                token.lexeme = "*";
            }
        case r'(' =>
            token.tokentype = L_BRACKET;
            token.lexeme = "("
        case r')' =>
            token.tokentype = R_BRACKET;
            token.lexeme = ")"
        case r',' =>
            token.tokentype = COMMA;
            token.lexeme = ",";
        case r';' =>
            token.tokentype = SEMICO;
            token.lexeme = ";";
        case _ =>
            //èµ°åˆ°è¿™é‡Œå°±æ˜¯é”™è¯¯ç¬¦å·
            token.tokentype = ERRTOKEN;
            token.lexeme = String(ch);
    }
    return token;
}
//åˆå§‹åŒ–è¯æ³•åˆ†æå™¨
public func initscanner(filePath:Path):Int64{
    try{
        file = File(filePath, Read);
    }catch(e:Exception){
        println("filePath ${filePath} not found");
        return 0;
    }
    file?.read(bytesBuf);
    return 1;
}
//å…³é—­è¯æ³•åˆ†æå™¨
public func closescanner(){
    file?.close();
}

//-----------------------------------------è¾…åŠ©å‡½æ•°---------------------------------
//è¯»å–ä¸€ä¸ªå­—ç¬¦
private func readrune():Rune{
    let r:Rune = Rune(bytesBuf[index]);
    index++;
    return r;
}
//å›é€€ä¸€ä¸ªå­—ç¬¦
private func backrune(){
    index--;
}
//åˆ¤æ–­æ˜¯å¦æ˜¯EOF
private func ch_is_EOF():Bool{
    return bytesBuf[index-1]==0;
}
